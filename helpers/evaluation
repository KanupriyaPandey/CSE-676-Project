# Function to evaluate model
def evaluate(encoder, decoder, sentence, input_language, output_language):
    with torch.no_grad():

        indexes = [input_language.word2index[word] for word in sentence.split(' ')]
        indexes.append(EOS_token)
        input_tensor = torch.tensor(indexes, dtype=torch.long, device=device).view(1, -1)

        encoder_outputs, encoder_hidden = encoder(input_tensor)
        decoder_outputs, decoder_hidden, decoder_attn = decoder(encoder_outputs, encoder_hidden)

        _, topi = decoder_outputs.topk(1)
        decoded_ids = topi.squeeze()

        decoded_words = []
        for idx in decoded_ids:
            if idx.item() == EOS_token:
                decoded_words.append('<EOS>')
                break
            decoded_words.append(output_language.index2word[idx.item()])

    return decoded_words, decoder_attn

# Function to evaluate and print translation sample
def evaluate_training_sample(encoder, decoder, train_pairs, number=10):
    for i in range(number):
        pair = random.choice(train_pairs)
        
        input = pair[0]
        target = pair[1]

        output_tokens, _ = evaluate(encoder, decoder, input, input_language, output_language)
        output = ' '.join(output_tokens)

        print('Input >', input)
        print('Target =', target)
        print('Output <', output)

# Function to generate translations for Bleu
def generate_translation(pairs, candidate_corpus, references_corpus):
    for i in range(len(pairs)):
        pair = pairs[i]
        print('Input >', pair[0])

        target_tokens = pair[1].split()
        print('Target =', target_tokens)

        pred_tokens, _ = evaluate(encoder, decoder, pair[0], input_language, output_language)
        pred_tokens = pred_tokens[:-1]
        print('Output <', pred_tokens)

        candidate_corpus.append(pred_tokens)
        references_corpus.append([target_tokens])